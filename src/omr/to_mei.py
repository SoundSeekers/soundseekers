import xml.etree.ElementTree as ET
import uuid
import datetime

# Mapping of duration words to numeric values
duration_map = {
    "whole": "1",
    "half": "2",
    "quarter": "4",
    "eighth": "8",
    "sixteenth": "16",
    "thirtysecond": "32",
}

def generate_id(prefix):
    return f"{prefix}-{uuid.uuid4().hex[:16]}"

def parse_semantic_representation(semantic_str):
    elements = semantic_str.split('\t')
    parsed_data = {
        "clef": None,
        "keySignature": None,
        "timeSignature": None,
        "measures": []
    }
    measure = []

    for element in elements:
        if element.startswith("clef-"):
            parsed_data["clef"] = element.split("-")[1]
        elif element.startswith("keySignature-"):
            parsed_data["keySignature"] = element.split("-")[1]
        elif element.startswith("timeSignature-"):
            parsed_data["timeSignature"] = element.split("-")[1]
        elif element == "barline":
            if measure:
                parsed_data["measures"].append(measure)
                measure = []
        else:
            measure.append(element)

    if measure:
        parsed_data["measures"].append(measure)

    return parsed_data

def create_mei(parsed_data):
    mei = ET.Element("mei", xmlns="http://www.music-encoding.org/ns/mei", meiversion="4.0.0")
    mei_head = ET.SubElement(mei, "meiHead")
    file_desc = ET.SubElement(mei_head, "fileDesc")
    title_stmt = ET.SubElement(file_desc, "titleStmt")
    ET.SubElement(title_stmt, "title")
    pub_stmt = ET.SubElement(file_desc, "pubStmt")
    ET.SubElement(pub_stmt, "date").text = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    encoding_desc = ET.SubElement(mei_head, "encodingDesc")
    project_desc = ET.SubElement(encoding_desc, "projectDesc")
    ET.SubElement(project_desc, "p").text = "Generated by Python Script"

    music = ET.SubElement(mei, "music")
    body = ET.SubElement(music, "body")
    mdiv = ET.SubElement(body, "mdiv")
    score = ET.SubElement(mdiv, "score")

    score_def = ET.SubElement(score, "scoreDef", xml_id=generate_id("scoredef"))
    if parsed_data["keySignature"]:
        score_def.set("key.sig", "3f" if parsed_data["keySignature"] == "EbM" else "0")

    if parsed_data["timeSignature"]:
        time_sig = parsed_data["timeSignature"]
        if time_sig == "C/":  # Common Time (4/4)
            score_def.set("meter.count", "4")
            score_def.set("meter.unit", "4")
        elif "/" in time_sig:
            try:
                meter_count, meter_unit = time_sig.split("/")
                score_def.set("meter.count", meter_count)
                score_def.set("meter.unit", meter_unit)
            except ValueError:
                print(f"Error: Invalid time signature format: {time_sig}")
        elif time_sig == "C|":  # Cut Time (2/2)
            score_def.set("meter.count", "2")
            score_def.set("meter.unit", "2")
        else:
            print(f"Warning: Unrecognized time signature: {time_sig}")

    staff_grp = ET.SubElement(score_def, "staffGrp", xml_id=generate_id("staffgrp"))
    staff_def = ET.SubElement(staff_grp, "staffDef", xml_id=generate_id("staffdef"), n="1", lines="5")
    if parsed_data["clef"]:
        clef_shape, clef_line = parsed_data["clef"][0], parsed_data["clef"][1]
        staff_def.set("clef.shape", clef_shape)
        staff_def.set("clef.line", clef_line)

    section = ET.SubElement(score, "section", xml_id=generate_id("section"))

    for measure_data in parsed_data["measures"]:
        measure = ET.SubElement(section, "measure", xml_id=generate_id("measure"), right="single")
        staff = ET.SubElement(measure, "staff", xml_id=generate_id("staff"), n="1")
        layer = ET.SubElement(staff, "layer", xml_id=generate_id("layer"), n="1")

        for item in measure_data:
            if item.startswith("rest-"):
                _, duration_word = item.split("-")
                # Convert the word to a numeric value using the duration_map
                duration = duration_map.get(duration_word, "4")  # Default to "4" if not found
                ET.SubElement(layer, "rest", xml_id=generate_id("rest"), dur=duration)
            elif item.startswith("note-"):
                note_info = item.split("-")[1]
                note_name, duration_word = note_info.split("_")

                # Extract step (A-G), accidental, and octave
                step = note_name[0].upper()  # First letter (A-G)
                accidental = note_name[1:-1]  # Middle part (if any, e.g., 'b' or '#')
                oct_val = note_name[-1]  # Last character (octave)

                # Convert duration word to numeric value
                duration = duration_map.get(duration_word, "4")  # Default to "4"

                # Create note element
                note_element = ET.SubElement(layer, "note", xml_id=generate_id("note"), dur=duration, pname=step.lower(), oct=oct_val)

                # Add alter element if the note has an accidental
                if accidental == "b":
                    ET.SubElement(note_element, "alter").text = "-1"  # Flat
                elif accidental == "#":
                    ET.SubElement(note_element, "alter").text = "1"  # Sharp
            elif item.startswith("multirest-"):
                _, num = item.split("-")
                ET.SubElement(layer, "multiRest", xml_id=generate_id("multirest"), num=num)

    return ET.ElementTree(mei)

def convert_to_mei(semantic_str, output_file):
    parsed_data = parse_semantic_representation(semantic_str)
    mei_tree = create_mei(parsed_data)
    mei_tree.write(output_file, encoding="utf-8", xml_declaration=True)

# Example usage
with open("./semantic_output", "r", encoding="utf-8") as file:
    semantic_representation = file.read().strip()
convert_to_mei(semantic_representation, "output.mei")
